const { sbox } = require("./SBox.js");
const crypto = require("crypto");

/**
 * * The function generates AES key based on the system timestamp.
 * * The timestamp is then hashed with SHA and converted to hexadecimal format and returned.
 *
 * @returns 256bit (32 bytes) long AES key in hex format.
 */
function generateKey() {
  const date = new Date().toString(32);
  const aesKey = crypto.createHash("sha256").update(date).digest("hex");

  return aesKey;
}

/**
 * * This method rotates the provided array by mentioned shift position.
 *
 * @param {*} array Accepts every row of the 4x4 matrix.
 * @param {*} shiftPos Indicates the number of positions to be shifted.
 * @returns the shifted array.
 */
function rotateRight(array, shiftPos) {
  let length = array.length;
  shiftPos = shiftPos % length;

  return array.slice(shiftPos).concat(array.slice(0, shiftPos));
}

/**
 * * This method is used in the keyExpansion method.
 * * It rotates the word by 1 position / 1 Byte.
 *
 * @param {*} word  A hex value usually 8 digits for aes-256.
 * @returns  The rotated word.
 */
function rotword(word) {
  return word.slice(2) + word.slice(0, 2);
}

/**
 *
 * * This method is used in the keyExpansion method.
 * * It substitutes the hex values of the word using the sbox.
 * * The result is then converted to hex
 *
 * @param {*} word  A hex value usually 8 digits for aes-256.
 * @returns The substituted word.
 */
function subWord(word) {
  let groupedHexValues = [];
  for (let i = 0; i < word.length; i += 2) {
    groupedHexValues.push(word.slice(i, i + 2));
  }

  const subworded = groupedHexValues
    .map((byte) => sbox[parseInt(byte, 16)].toString(16).padStart(2, "0"))
    .join("");

  return subworded;
}

/**
 * * XOR operation on two hex values.
 * * This method is used in the keyExpansion method.
 * * The XOR operation is done on each byte of the two hex values.
 * * The result is then converted to hex and returned.
 *
 * * For aes-256, value1 is the result of the previous word operations and value2 is w[i-8].
 *
 * @param {*} value1 A hex value usually 8 digits for aes-256.
 * @param {*} value2 another hex value usually 8 digits for aes-256.
 * @returns XOR of the above two values.
 */
function XOR(value1, value2) {
  let result = "";
  for (let j = 0; j < value1.length; j += 2) {
    let byteFromResult = parseInt(value1.slice(j, j + 2), 16);
    let byteFromW = parseInt(value2.slice(j, j + 2), 16);

    result += (byteFromResult ^ byteFromW).toString(16).padStart(2, "0");
  }
  return result;
}

/**
 * ? Key Expansion in AES-256:
 *
 * * Key Length: 256 bits (32 bytes).
 * * Number of Rounds: 14.
 * * Nk = 8
 * * Total Expanded Key Words: 60
 *
 * * The first 8 words are directly taken from the key.
 * * New words are generated using a combination of the previous words,
 * * the RotWord, SubWord, and XOR with Rcon operations and its result with w[i-Nk] to get w[i].
 *
 * * The expanded key words are used in the AddRoundKey step for each of the 14 rounds of AES-256.
 *
 * @param {*} key The key is the initial key generated by the system for symmetric encryption in AES.
 * @returns This method returns the expanded key.
 */
function keyExpansion(key) {
  /**
   * rcon = Round Constant
   * Contains round constants to be used for each round.
   * Each constant is XORed only with the first byte of the word, and only when (i % Nk == 0).
   * Nk = 8 for AES-256.
   */
  const rcon = [
    "0x01", //1
    "0x02", //2
    "0x04", //4
    "0x08", //8
    "0x10", //16
    "0x20", //32
    "0x40", //64
  ];

  const w = new Array(60);

  for (let i = 0; i < 8; i++) {
    w[i] = key.slice(i * 8, i * 8 + 8);
  }

  for (let i = 8; i < 60; i++) {
    let temp = w[i - 1];

    if (i % 8 === 0) {
      temp = subWord(rotword(temp));

      const wordFirstValuePair = parseInt(temp.slice(0, 2), 16);
      const rconDecimalEquiv = parseInt(rcon[i / 8 - 1], 16);

      temp =
        (wordFirstValuePair ^ rconDecimalEquiv).toString(16).padStart(2, "0") +
        temp.slice(2);

      temp = XOR(temp, w[i - 8]);
    } else if (i % 8 === 4) {
      temp = subWord(temp);
      temp = XOR(temp, w[i - 8]);
    } else {
      temp = XOR(temp, w[i - 8]);
    }

    w[i] = temp;
  }

  return w;
}

/**
 *
 * @param {*} string
 * @returns
 */
function stringToHex(string) {
  return string
    .split("")
    .map((char) => char.charCodeAt(0).toString(16).padStart(2, "0"))
    .join("");
}

/**
 *
 * @param {*} hexStr
 * @returns
 */
function padTo16Bytes(hexStr) {
  // PKCS#7 Padding
  const blockSize = 16; // 16 bytes (128 bits)
  const hexBytesLength = hexStr.length / 2;
  const paddingLength = blockSize - (hexBytesLength % blockSize);

  const paddingHex = paddingLength.toString(16).padStart(2, "0");
  return hexStr + paddingHex.repeat(paddingLength);
}

/**
 *
 * @param {*} state
 * @param {*} expandedKey
 * @param {*} round
 */
function addRoundKey(state, expandedKey, round) {
  const roundKey = expandedKey.slice(round * 4, (round + 1) * 4);
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 4; col++) {
      state[row][col] = XOR(
        state[row][col],
        roundKey[col].slice(2 * row, 2 * row + 2)
      );
    }
  }
  // return state;
}

/**
 *
 * @param {*} state
 */
function substituteBytes(state) {
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 4; col++) {
      // Convert the hex value in state to decimal, then substitute using S-box
      const byte = parseInt(state[row][col], 16);
      state[row][col] = sbox[byte].toString(16).padStart(2, "0"); // Ensure 2-digit hex value
    }
  }
}

/**
 * ? Shift Row stage
 * * This stage is repeated in every round (upto N)
 * * In this, circular shiting happens in every row of the 4x4 matrix.
 * * First row is shifted by 0, second by 1, third by 2 and fourth by 3 position.
 *
 * @param {*} state The parameter `state` is the current state of the matrix. Its value changes in every round.
 */
function shiftRows(state) {
  let shiftBy = 0;

  state.forEach((row) => {
    state[shiftBy] = rotateRight(row, shiftBy);
    shiftBy++;
  });
}

/**
 * * Diffusion layer of AES.
 * * A common `MIX_COLUMN_MATRIX` is used to ensure all the blocks have common diffusion.
 *
 * @param {*} state
 */
function mixColumns(state) {
  const mul2 = [
    0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16,
    0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e,
    0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46,
    0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
    0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76,
    0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e,
    0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6,
    0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
    0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6,
    0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee,
    0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x1b, 0x19, 0x1f, 0x1d,
    0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
    0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d,
    0x23, 0x21, 0x27, 0x25, 0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55,
    0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 0x7b, 0x79, 0x7f, 0x7d,
    0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
    0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d,
    0x83, 0x81, 0x87, 0x85, 0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5,
    0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 0xdb, 0xd9, 0xdf, 0xdd,
    0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
    0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed,
    0xe3, 0xe1, 0xe7, 0xe5,
  ];

  const mul3 = [
    0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d,
    0x14, 0x17, 0x12, 0x11, 0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39,
    0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21, 0x60, 0x63, 0x66, 0x65,
    0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
    0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d,
    0x44, 0x47, 0x42, 0x41, 0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9,
    0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1, 0xf0, 0xf3, 0xf6, 0xf5,
    0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
    0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd,
    0xb4, 0xb7, 0xb2, 0xb1, 0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99,
    0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81, 0x9b, 0x98, 0x9d, 0x9e,
    0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
    0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6,
    0xbf, 0xbc, 0xb9, 0xba, 0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2,
    0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea, 0xcb, 0xc8, 0xcd, 0xce,
    0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
    0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46,
    0x4f, 0x4c, 0x49, 0x4a, 0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62,
    0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a, 0x3b, 0x38, 0x3d, 0x3e,
    0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
    0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16,
    0x1f, 0x1c, 0x19, 0x1a,
  ];

  for (let col = 0; col < 4; col++) {
    let s0 = parseInt(state[0][col], 16);
    let s1 = parseInt(state[1][col], 16);
    let s2 = parseInt(state[2][col], 16);
    let s3 = parseInt(state[3][col], 16);

    // Perform the matrix multiplication with the MixColumns constant matrix
    let t0 = mul2[s0] ^ mul3[s1] ^ s2 ^ s3;
    let t1 = s0 ^ mul2[s1] ^ mul3[s2] ^ s3;
    let t2 = s0 ^ s1 ^ mul2[s2] ^ mul3[s3];
    let t3 = mul3[s0] ^ s1 ^ s2 ^ mul2[s3];

    // Update the state with the new values
    state[0][col] = t0.toString(16).padStart(2, "0");
    state[1][col] = t1.toString(16).padStart(2, "0");
    state[2][col] = t2.toString(16).padStart(2, "0");
    state[3][col] = t3.toString(16).padStart(2, "0");
  }
}

/**
 * * This is the main encryption function. Each operation of AES happens from here.
 * * This method is responsible for encrypting the message and saving it to the file.
 *
 * @param {*} key
 * @param {*} iv
 * @param {*} message
 * @returns This method returns the key.
 */
async function encryptWithIV(key, iv, message) {
  /**
   * * The message is converted hex, padded and then to a 4x4 matrix.
   */
  // Converting message to hex.
  let state = stringToHex(message);
  // Padding the message to 16 bytes.
  state = padTo16Bytes(state);

  // Converting message to 4x4 array.
  let matrix = [];
  for (let itr = 0; itr < state.length / 32; itr++) {
    matrix[itr] = [];
    for (let i = 0; i < 4; i++) {
      matrix[itr][i] = [];
      for (let j = 0; j < 4; j++) {
        const bytePosition = (j * 4 + i) * 2; // Column-major order
        matrix[itr][i][j] = state
          .slice(itr * 32, (itr + 1) * 32)
          .slice(bytePosition, bytePosition + 2)
          .padStart(2, "0");
      }
    }
  }

  //converting iv to matrix
  const ivMatrix = [];
  for (let i = 0; i < 4; i++) {
    ivMatrix[i] = [];
    for (let j = 0; j < 4; j++) {
      const bytePosition = (j * 4 + i) * 2;
      ivMatrix[i][j] = iv
        .slice(bytePosition, bytePosition + 2)
        .padStart(2, "0");
    }
  }

  //XOR with IV
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      matrix[0][i][j] = (
        parseInt(matrix[0][i][j], 16) ^ parseInt(ivMatrix[i][j], 16)
      )
        .toString(16)
        .padStart(2, "0");
    }
  }

  /**
   * Generating the expanded key.
   */
  expanded_key = keyExpansion(key);

  /**
   * Add Round Key stage
   */
  addRoundKey(matrix[0], expanded_key, 0);

  for (let round = 1; round < 14; round++) {
    //Substitute Bytes
    substituteBytes(matrix[0]);
    //Shift Rows
    shiftRows(matrix[0]);
    //Mix Columns
    mixColumns(matrix[0]);
    //Add Round Key
    addRoundKey(matrix[0], expanded_key, round);
  }

  //Substitute Bytes
  substituteBytes(matrix[0]);
  //Shift Rows
  shiftRows(matrix[0]);
  //Add Round Key
  addRoundKey(matrix[0], expanded_key, 14);

  const transposed = matrix[0].map((_, colIndex) =>
    matrix[0].map((row) => row[colIndex])
  );
}
