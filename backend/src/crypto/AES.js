const { sbox } = require("./SBox.js");
const crypto = require("crypto");

/**
 * * The function generates AES key based on the system timestamp.
 * * The timestamp is then hashed with SHA and converted to hexadecimal format and returned.
 *
 * @returns 256bit (32 bytes) long AES key in hex format.
 */
function generateKey() {
  const date = new Date().toString(32);
  const aesKey = crypto.createHash("sha256").update(date).digest("hex");

  return aesKey;
}

/**
 * * This method rotates the provided array by mentioned shift position.
 *
 * @param {*} array Accepts every row of the 4x4 matrix.
 * @param {*} shiftPos Indicates the number of positions to be shifted.
 * @returns the shifted array.
 */
function rotateRight(array, shiftPos) {
  let length = array.length;
  shiftPos = shiftPos % length;

  return array.slice(shiftPos).concat(array.slice(0, shiftPos));
}

/**
 * ? Shift Row stage
 * * This stage is repeated in every round (upto N)
 * * In this, circular shiting happens in every row of the 4x4 matrix.
 * * First row is shifted by 0, second by 1, third by 2 and fourth by 3 position.
 *
 * @param {*} state The parameter `state` is the current state of the matrix. Its value changes in every round.
 */
function shiftRows(state) {
  let shiftBy = 0;

  state.forEach((row) => {
    state[shiftBy] = rotateRight(row, shiftBy);
    shiftBy++;
  });
}

/**
 * * This method is used in the keyExpansion method.
 * * It rotates the word by 1 position / 1 Byte.
 *
 * @param {*} word  A hex value usually 8 digits for aes-256.
 * @returns  The rotated word.
 */
function rotword(word) {
  return word.slice(2) + word.slice(0, 2);
}

/**
 *
 * * This method is used in the keyExpansion method.
 * * It substitutes the hex values of the word using the sbox.
 * * The result is then converted to hex
 *
 * @param {*} word  A hex value usually 8 digits for aes-256.
 * @returns The substituted word.
 */
function subWord(word) {
  // console.log("In SW: Word: ", word);
  let groupedHexValues = [];
  for (let i = 0; i < word.length; i += 2) {
    groupedHexValues.push(word.slice(i, i + 2));
  }

  const subworded = groupedHexValues
    .map((byte) => sbox[parseInt(byte, 16)].toString(16).padStart(2, "0"))
    .join("");

  return subworded;
}

/**
 * * XOR operation on two hex values.
 * * This method is used in the keyExpansion method.
 * * The XOR operation is done on each byte of the two hex values.
 * * The result is then converted to hex and returned.
 *
 * * For aes-256, value1 is the result of the previous word operations and value2 is w[i-8].
 *
 * @param {*} value1 A hex value usually 8 digits for aes-256.
 * @param {*} value2 another hex value usually 8 digits for aes-256.
 * @returns XOR of the above two values.
 */
function XOR(value1, value2) {
  let result = "";
  for (let j = 0; j < value1.length; j += 2) {
    let byteFromResult = parseInt(value1.slice(j, j + 2), 16);
    let byteFromW = parseInt(value2.slice(j, j + 2), 16);

    result += (byteFromResult ^ byteFromW).toString(16).padStart(2, "0");
  }
  return result;
}

/**
 * ? Key Expansion in AES-256:
 *
 * * Key Length: 256 bits (32 bytes).
 * * Number of Rounds: 14.
 * * Nk = 8
 * * Total Expanded Key Words: 60
 *
 * * The first 8 words are directly taken from the key.
 * * New words are generated using a combination of the previous words,
 * * the RotWord, SubWord, and XOR with Rcon operations and its result with w[i-Nk] to get w[i].
 *
 * * The expanded key words are used in the AddRoundKey step for each of the 14 rounds of AES-256.
 *
 * @param {*} key The key is the initial key generated by the system for symmetric encryption in AES.
 * @returns This method returns the expanded key.
 */
function keyExpansion(key) {
  /**
   * rcon = Round Constant
   * Contains round constants to be used for each round.
   * Each constant is XORed only with the first byte of the word, and only when (i % Nk == 0).
   * Nk = 8 for AES-256.
   */
  const rcon = [
    "0x01", //1
    "0x02", //2
    "0x04", //4
    "0x08", //8
    "0x10", //16
    "0x20", //32
    "0x40", //64
  ];

  const w = new Array(60);

  for (let i = 0; i < 8; i++) {
    w[i] = key.slice(i * 8, i * 8 + 8);
  }

  for (let i = 8; i < 60; i++) {
    // console.log("for i:", i);
    let temp = w[i - 1];

    if (i % 8 === 0) {
      temp = subWord(rotword(temp));

      const wordFirstValuePair = parseInt(temp.slice(0, 2), 16);
      const rconDecimalEquiv = parseInt(rcon[i / 8 - 1], 16);

      temp =
        (wordFirstValuePair ^ rconDecimalEquiv).toString(16).padStart(2, "0") +
        temp.slice(2);

      temp = XOR(temp, w[i - 8]);
    } else if (i % 8 === 4) {
      temp = subWord(temp);
      temp = XOR(temp, w[i - 8]);
    } else {
      temp = XOR(temp, w[i - 8]);
    }

    w[i] = temp;
  }

  return w;
}

/**
 *
 * @param {*} string
 * @returns
 */
function stringToHex(string) {
  return string
    .split("")
    .map((char) => char.charCodeAt(0).toString(16).padStart(2, "0"))
    .join("");
}

/**
 *
 * @param {*} hexStr
 * @returns
 */
function padTo16Bytes(hexStr) {
  // PKCS#7 Padding
  const blockSize = 16; // 16 bytes (128 bits)
  const hexBytesLength = hexStr.length / 2;
  const paddingLength = blockSize - (hexBytesLength % blockSize);

  const paddingHex = paddingLength.toString(16).padStart(2, "0");
  return hexStr + paddingHex.repeat(paddingLength);
}

/**
 *
 */
function mixColumns() {}

/**
 * * This is the main encryption function. Each operation of AES happens from here.
 * * This method is responsible for encrypting the message and saving it to the file.
 *
 * @param {*} key
 * @param {*} iv
 * @param {*} message
 * @returns This method returns the key.
 */
async function encryptWithIV(key, iv, message) {
  expanded_key = keyExpansion(key);

  // Converting message to hex.
  let state = stringToHex(message);
  
  // Padding the message to 16 bytes.
  state = padTo16Bytes(state);
  
  // Converting message to 4x4 array.
  let matrix = [];
  for (let itr = 0; itr < state.length / 32; itr++) {
    matrix[itr] = [];
    for (let i = 0; i < 4; i++) {
      matrix[itr][i] = [];
      for (let j = 0; j < 4; j++) {
        const bytePosition = (j * 4 + i) * 2; // Column-major order
        matrix[itr][i][j] = state
          .slice(itr * 32, (itr + 1) * 32)
          .slice(bytePosition, bytePosition + 2)
          .padStart(2, "0");

      }
    }
  }

  console.log(matrix);
  
  // TODO: Add Round Key
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      matrix[0][i][j] = (
        parseInt(matrix[0][i][j], 16) ^ parseInt(ivMatrix[i][j], 16)
      ).toString(16).padStart(2, "0");
    }
  }

  console.log("Matrix after XOR with IV (initial add round key):", matrix);

  console.log("Halo");

  for (let round = 1; round < 14; round++) {
    //Substitute Bytes
  }
}

// const key = generateKey();
const key = "f6cf0f762165be595078750643922f28c38ff5acb64d1c0e6fd53593228b9a12";
const iv = crypto.randomBytes(16).toString("hex");

encryptWithIV(key, iv, "ABCDEFGHIJKLMNOPQRST");
