const { sbox, invSbox } = require("./SBox.js");
const { mul2, mul3, mul9, mul11, mul13, mul14 } = require("./LookupTables.js");
const crypto = require("crypto");
const sha256 = require("./sha256.js");
const fs = require("fs");

class AES_test {
  constructor() {
    this.key = this.#generateKey();
    this.iv = crypto.randomBytes(16);
  }
  /**
   * * The function generates AES key based on the system timestamp.
   * * The timestamp is then hashed with SHA and converted to hexadecimal format and returned.
   *
   * @returns 256bit (32 bytes) long AES key in hex format.
   */
  #generateKey() {
    const date = new Date().toString(32);
    const aesKey = crypto.createHash("sha256").update(date).digest();
    // const aesKey = new sha256().hash(date);

    return aesKey;
  }

  /**
   * * This method rotates the provided array by mentioned shift position.
   *
   * @param {*} array Accepts every row of the 4x4 matrix.
   * @param {*} shiftPos Indicates the number of positions to be shifted.
   * @returns the shifted array.
   */
  #rotateRight(array, shiftPos) {
    let length = array.length;
    shiftPos = shiftPos % length;

    return array.slice(shiftPos).concat(array.slice(0, shiftPos));
  }

  /**
   * * This method is used in the keyExpansion method.
   * * It rotates the word by 1 position / 1 Byte.
   *
   * @param {*} word  A hex value usually 8 digits for aes-256.
   * @returns  The rotated word.
   */
  #rotword(wordBuffer) {
    return Buffer.concat([wordBuffer.slice(1), wordBuffer.slice(0, 1)]);
  }

  /**
   *
   * * This method is used in the keyExpansion method.
   * * It substitutes the hex values of the word using the sbox.
   * * The result is then converted to hex
   *
   * @param {*} word  A hex value usually 8 digits for aes-256.
   * @returns The substituted word.
   */
  #subWord(wordBuffer) {
    const result = Buffer.alloc(wordBuffer.length);
    for (let i = 0; i < wordBuffer.length; i++) {
      result[i] = sbox[wordBuffer[i]]; // Substitutes each byte using sbox
    }
    return result;
  }

  /**
   * * XOR operation on two hex values.
   * * This method is used in the keyExpansion method.
   * * The XOR operation is done on each byte of the two hex values.
   * * The result is then converted to hex and returned.
   *
   * * For aes-256, value1 is the result of the previous word operations and value2 is w[i-8].
   *
   * @param {*} value1 A hex value usually 8 digits for aes-256.
   * @param {*} value2 another hex value usually 8 digits for aes-256.
   * @returns XOR of the above two values.
   */
  #XOR(buffer1, buffer2) {
    const result = Buffer.alloc(buffer1.length);
    for (let i = 0; i < buffer1.length; i++) {
      result[i] = buffer1[i] ^ buffer2[i]; // XOR each byte
    }
    return result;
  }

  /**
   * ? Key Expansion in AES-256:
   *
   * * Key Length: 256 bits (32 bytes).
   * * Number of Rounds: 14.
   * * Nk = 8
   * * Total Expanded Key Words: 60
   *
   * * The first 8 words are directly taken from the key.
   * * New words are generated using a combination of the previous words,
   * * the RotWord, SubWord, and XOR with Rcon operations and its result with w[i-Nk] to get w[i].
   *
   * * The expanded key words are used in the AddRoundKey step for each of the 14 rounds of AES-256.
   *
   * @param {*} key The key is the initial key generated by the system for symmetric encryption in AES.
   * @returns This method returns the expanded key.
   */
  #keyExpansion(key) {
    /**
     * rcon = Round Constant
     * Contains round constants to be used for each round.
     * Each constant is XORed only with the first byte of the word, and only when (i % Nk == 0).
     * Nk = 8 for AES-256.
     */
    const rcon = [
      0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
      0xab, 0x4d, 0x9a,
    ];

    const w = new Array(60);

    // First 8 words are just the key itself split into 8-byte chunks
    for (let i = 0; i < 8; i++) {
      w[i] = key.slice(i * 4, (i + 1) * 4); // Slice key into 4-byte chunks
    }

    for (let i = 8; i < 60; i++) {
      let temp = Buffer.from(w[i - 1]); // Copy previous word

      if (i % 8 === 0) {
        // Apply the subWord and rotWord functions
        temp = this.#subWord(this.#rotword(temp));

        // XOR the first byte of the word with the rcon value
        temp[0] ^= rcon[i / 8 - 1]; // Rcon is only applied to the first byte

        // XOR with the word 8 positions before
        temp = this.#XOR(temp, w[i - 8]);
      } else if (i % 8 === 4) {
        // For AES-256, subWord is applied every 4th word
        temp = this.#subWord(temp);

        // XOR with the word 8 positions before
        temp = this.#XOR(temp, w[i - 8]);
      } else {
        // Just XOR with the word 8 positions before
        temp = this.#XOR(temp, w[i - 8]);
      }

      w[i] = temp;
    }
    return w;
  }

  /**
   *
   * @param {*} hexStr
   * @returns
   */
  #padTo16Bytes(buffer) {
    // PKCS#7 Padding
    const blockSize = 16;
    const paddingLength = blockSize - (buffer.length % blockSize);
    const padding = Buffer.alloc(paddingLength, paddingLength);
    return Buffer.concat([buffer, padding]);
  }

  /**
   *
   * @param {*} state
   * @param {*} expandedKey
   * @param {*} round
   */
  #addRoundKey(state, expandedKey, round) {
    const roundKeyStartIndex = round * 16; // Each round key is 16 bytes
    const roundKey = expandedKey.slice(
      roundKeyStartIndex,
      roundKeyStartIndex + 16
    );

    for (let row = 0; row < 4; row++) {
      for (let col = 0; col < 4; col++) {
        const roundKeyByte = roundKey[row + col * 4]; // Access the correct byte for state transformation
        state[row][col] ^= roundKeyByte; // XOR with the state
      }
    }
  }

  /**
   *
   * @param {*} state
   */
  #substituteBytes(state) {
    for (let row = 0; row < 4; row++) {
      for (let col = 0; col < 4; col++) {
        const byte = state[row][col]; // Assuming state[row][col] is a single byte value
        // Substitute using the S-box
        state[row][col] = sbox[byte]; // Directly store the substituted value
      }
    }
  }

  /**
   * * This  is similar to the `substituteBytes`  in encryption
   * * but uses the inverse S-box to reverse the substitution.
   *
   * @param {*} state The current state of the matrix during decryption.
   */
  #inverseSubstituteBytes(state) {
    for (let row = 0; row < 4; row++) {
      for (let col = 0; col < 4; col++) {
        const byte = state[row][col]; // Assuming state[row][col] is a single byte value
        state[row][col] = invSbox[byte]; // Substitute directly
      }
    }
  }

  /**
   * Shift Row stage
   * This stage is repeated in every round (up to N).
   * In this, circular shifting happens in every row of the 4x4 matrix.
   * First row is shifted by 0, second by 1, third by 2, and fourth by 3 positions.
   *
   * @param {*} state The parameter `state` is the current state of the matrix.
   */
  #shiftRows(state) {
    for (let row = 0; row < 4; row++) {
      state[row] = this.#rotateRight(state[row], row); // Shift row by its index
    }
  }

  /**
   * This function reverses the ShiftRows step by shifting the rows back to their original positions.
   *
   * @param {*} state The current state of the matrix during decryption.
   */
  #inverseShiftRows(state) {
    for (let row = 0; row < 4; row++) {
      state[row] = this.#rotateRight(state[row], 4 - row); // Shift back to original position
    }
  }

  /**
   * Diffusion layer of AES.
   * A common `MIX_COLUMN_MATRIX` is used to ensure all the blocks have common diffusion.
   *
   * @param {*} state
   */
  #mixColumns(state) {
    for (let col = 0; col < 4; col++) {
      const s0 = state[0][col];
      const s1 = state[1][col];
      const s2 = state[2][col];
      const s3 = state[3][col];

      // Perform the matrix multiplication with the MixColumns constant matrix
      const t0 = mul2[s0] ^ mul3[s1] ^ s2 ^ s3;
      const t1 = s0 ^ mul2[s1] ^ mul3[s2] ^ s3;
      const t2 = s0 ^ s1 ^ mul2[s2] ^ mul3[s3];
      const t3 = mul3[s0] ^ s1 ^ s2 ^ mul2[s3];

      // Update the state with the new values
      state[0][col] = t0;
      state[1][col] = t1;
      state[2][col] = t2;
      state[3][col] = t3;
    }
  }

  /**
   * This function reverses the MixColumns transformation using inverse MixColumns logic.
   * AES decryption has a specific inverse MixColumn operation.
   *
   * @param {*} state The current state of the matrix during decryption.
   */
  #inverseMixColumns(state) {
    for (let col = 0; col < 4; col++) {
      const s0 = state[0][col];
      const s1 = state[1][col];
      const s2 = state[2][col];
      const s3 = state[3][col];

      // Perform the matrix multiplication with the MixColumns constant matrix
      const t0 = mul14[s0] ^ mul11[s1] ^ mul13[s2] ^ mul9[s3];
      const t1 = mul9[s0] ^ mul14[s1] ^ mul11[s2] ^ mul13[s3];
      const t2 = mul13[s0] ^ mul9[s1] ^ mul14[s2] ^ mul11[s3];
      const t3 = mul11[s0] ^ mul13[s1] ^ mul9[s2] ^ mul14[s3];

      // Update the state with the new values
      state[0][col] = t0;
      state[1][col] = t1;
      state[2][col] = t2;
      state[3][col] = t3;
    }
  }

  /**
   *
   * @param {*} state
   * @param {*} iv
   * @returns
   */
  #xorWithIV(state, iv) {
    for (let i = 0; i < state.length; i++) {
      for (let j = 0; j < state[i].length; j++) {
        state[i][j] ^= iv[i][j]; // XOR operation
      }
    }
    return state;
  }

  /**
   *
   * @param {*} hexString
   * @returns unpadded text (original cipher text)
   */
  #removePadding(buffer) {
    const paddingLength = buffer[buffer.length - 1]; // Last byte indicates the padding length
    return buffer.slice(0, buffer.length - paddingLength); // Return unpadded text
  }

  /**
   * Converts a buffer into a 4x4 matrix.
   *
   * @param {Buffer} buffer The input buffer (should be 16 bytes).
   * @returns {Array} A 4x4 matrix representation of the buffer.
   */
  #bufferToMatrix(buffer) {
    const matrix = [];
    for (let i = 0; i < 4; i++) {
      matrix[i] = [];
      for (let j = 0; j < 4; j++) {
        matrix[i][j] = buffer[i + 4 * j]; // Row-major order
      }
    }
    return matrix;
  }

  /**
   * Converts a 4x4 matrix back into a buffer.
   *
   * @param {Array} matrix The input 4x4 matrix.
   * @returns {Buffer} A buffer representation of the matrix (16 bytes).
   */
  #matrixToBuffer(matrix) {
    const buffer = Buffer.alloc(16); // Allocate 16 bytes for the buffer
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        buffer[i + 4 * j] = matrix[i][j]; // Fill buffer in row-major order
      }
    }
    return buffer;
  }

  /**
   * This is the main encryption function. Each operation of AES happens from here.
   * This method is responsible for encrypting the message and returning the ciphertext.
   *
   * @param {Buffer} key The AES encryption key (32 bytes for AES-256).
   * @param {Buffer} iv The initialization vector (IV) (16 bytes).
   * @param {Buffer} message The plaintext message to encrypt.
   *
   * @returns {Buffer} This method returns the encrypted message as ciphertext.
   */
  #encryptWithIV(key, iv, message) {
    // Convert message to a Buffer
    let state = Buffer.from(message);
    // Pad the message to ensure it is a multiple of 16 bytes
    state = this.#padTo16Bytes(state);

    // Convert IV to a 4x4 byte matrix
    let ivMatrix = this.#bufferToMatrix(iv);
    const expandedKey = this.#keyExpansion(key);

    // Calculate the number of blocks (each block is 16 bytes)
    const blockCount = state.length / 16;
    let cipherText = Buffer.alloc(0);

    // Process each block individually
    for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
      // Extract a single block of the message
      let block = state.slice(blockIndex * 16, (blockIndex + 1) * 16);

      // Convert block to a 4x4 state matrix
      let matrix = this.#bufferToMatrix(block);

      // XOR the current block with the IV
      matrix = this.#xorWithIV(matrix, ivMatrix);

      /**
       * Add Round Key stage (initial round)
       */
      this.#addRoundKey(matrix, expandedKey, 0);

      // Perform 14 rounds of encryption
      for (let round = 1; round <= 14; round++) {
        // Substitute Bytes
        this.#substituteBytes(matrix);
        // Shift Rows
        this.#shiftRows(matrix);
        // Mix Columns (not applied in the final round)
        if (round !== 14) this.#mixColumns(matrix);
        // Add Round Key
        this.#addRoundKey(matrix, expandedKey, round);
      }

      // Append the resulting ciphertext for this block
      cipherText = Buffer.concat([cipherText, this.#matrixToBuffer(matrix)]);

      // Update IV with the latest ciphertext block for the next block
      ivMatrix = matrix; // In CBC mode, the IV is the last ciphertext block
    }
    return cipherText; // Return the final ciphertext
  }

  /**
   * This method is responsible for decrypting the ciphertext using the AES algorithm.
   *
   * @param {Buffer} key The AES encryption key (32 bytes for AES-256).
   * @param {Buffer} iv The initialization vector (IV) (16 bytes).
   * @param {Buffer} cipherMessage The encrypted message (ciphertext) to decrypt.
   * @returns {Buffer} The decrypted plaintext message.
   */
  #decryptWithIV(key, iv, cipherMessage) {
    // Validate that the ciphertext length is a multiple of the block size (16 bytes)
    if (cipherMessage.length % 16 !== 0) {
      throw new Error("Ciphertext length is not a multiple of block size.");
    }

    const blockCount = cipherMessage.length / 16; // Number of 16-byte blocks
    let plaintext = Buffer.alloc(0); // Buffer to accumulate the decrypted plaintext

    // Convert IV to a 4x4 byte matrix
    let ivMatrix = this.#bufferToMatrix(iv);

    /**
     * Generate the expanded key for decryption.
     */
    const expandedKey = this.#keyExpansion(key);

    // Decrypt each block of ciphertext
    for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
      // Extract a single block of the ciphertext
      let block = cipherMessage.slice(blockIndex * 16, (blockIndex + 1) * 16);
      let matrix = this.#bufferToMatrix(block);

      /**
       * Add Round Key stage (initial round)
       */
      this.#addRoundKey(matrix, expandedKey, 14); // Start with the last round key

      // Perform decryption rounds
      for (let round = 13; round >= 0; round--) {
        // Inverse Shift Rows
        this.#inverseShiftRows(matrix);
        // Inverse Substitute Bytes
        this.#inverseSubstituteBytes(matrix);
        // Add Round Key
        this.#addRoundKey(matrix, expandedKey, round);
        // Inverse Mix Columns (not applied in the final round)
        if (round !== 0) this.#inverseMixColumns(matrix);
      }

      // XOR the decrypted block with the IV or the previous ciphertext block
      matrix = this.#xorWithIV(matrix, ivMatrix);
      ivMatrix = this.#bufferToMatrix(block); // Update IV to the current block

      // Concatenate the decrypted matrix to the plaintext buffer
      plaintext = Buffer.concat([plaintext, this.#matrixToBuffer(matrix)]);
    }

    // Remove padding from the final plaintext
    return this.#removePadding(plaintext);
  }

  /**
   * Encrypts the message using AES encryption.
   * This method generates a key and an IV for encryption.
   *
   * @param {string|Buffer} message The message to be encrypted (string or Buffer).
   * @returns {Buffer} The encrypted message as a Buffer.
   */
  AES_Encrypt(message) {
    // Call the internal encryption method with the key and IV
    const ciphermsg = this.#encryptWithIV(this.key, this.iv, message);
    return ciphermsg; // Return the encrypted message
  }

  /**
   * Decrypts the message using AES decryption.
   * This method uses the key and IV generated during encryption.
   *
   * @param {Buffer} key The AES encryption key used for decryption (32 bytes for AES-256).
   * @param {Buffer} iv The initialization vector used for decryption (16 bytes).
   * @param {Buffer} encryptedMessage The encrypted message (ciphertext) to be decrypted.
   * @returns {string} The decrypted message as a UTF-8 string.
   */
  AES_Decrypt(key, iv, encryptedMessage) {
    // Call the internal decryption method with the key, IV, and encrypted message
    const decipheredMessage = this.#decryptWithIV(key, iv, encryptedMessage);
    return decipheredMessage.toString("utf-8"); // Convert decrypted Buffer to UTF-8 string
  }
}

module.exports = AES_test;
